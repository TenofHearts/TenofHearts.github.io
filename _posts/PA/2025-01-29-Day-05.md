# 从0开始写PA-Day05

今天是大年初一, 先祝大家新春快乐. 希望大家在新的一年里身体健康, 学习工作顺利, 天天开心. 

从今天起, 我们就正式进入PA2了. 在PA2中, 我们需要实现一个[冯诺依曼计算机系统](https://zh.wikipedia.org/wiki/%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84). 也就是在这章中, 我们可以真正在虚拟机上跑起来一些程序啦!(耶!!!!!!!!)

## More on Programs

为了能够在我们自己写的虚拟机上运行程序, 我们必须要完整地理解一个程序运行的规则. 尽管在前面的文章中我对这方面有所涉及, 但是并没有将整个运行过程系统性地展现出来, 因此今天, 我还要更细致地介绍一下程序是如何在计算机上跑起来的. 

### Program(程序)

要想让程序在计算机上跑起来, 我们要先有一个程序(多新鲜呐). 下面, 我将围绕以下这段程序展开介绍. 

```c
int main()
{
    int a = 1, b = 0, tmp = 0;
    for (int i = 1; i <= 10; i++)
    {
        tmp = a;
        a = a + b;
        b = tmp;
    }
}
```

这段程序算出了10以内的斐波那契数列, 但是并没有用它完成任何事情. 要想执行这段代码, 我们还需要一个...

### Compiler(编译器)

目前来讲, 上面这段代码就是简单的文本, 对于机器来说, 他们并没有什么特殊的. 虽然我们可能将其命名为`fib.c`, 但是`.c`这个后缀名实际上并无什么特殊作用, 要是我们想的话, 也可以将其改成`.txt`, `.py`, 甚至`.mp3`这些其他后缀名, 而不产生什么影响. 想要执行这段代码, 我们必须有一个机器能够看懂的二进制可执行文件. 

一个编译器就是能将`C`, `Java`等高级语言变成可执行文件的工具. 不同语言有不同的编译器, 每种编译器还有对应不同架构的多个版本. 由于我的虚拟机使用的是Risc-V32架构, 因此我们需要使用gcc(`C`语言的一个编译器)的Risc-V32版本进行编译, 再将二进制文件转化成汇编语言(一种较为底层的低级语言), 就可以得到这样的一个文件: 

```assembly
# 内存地址       二进制指令                汇编代码

80000000 <_start>:
80000000:       00000413                li      s0,0
80000004:       00009117                auipc   sp,0x9
80000008:       ffc10113                addi    sp,sp,-4 # 80009000 <_end>
8000000c:       00c000ef                jal     ra,80000018 <_trm_init>

80000010 <main>:
80000010:       00000513                li      a0,0
80000014:       00008067                ret

80000018 <_trm_init>:
80000018:       ff010113                addi    sp,sp,-16
8000001c:       00000517                auipc   a0,0x0
80000020:       01c50513                addi    a0,a0,28 # 80000038 <_etext>
80000024:       00112623                sw      ra,12(sp)
80000028:       fe9ff0ef                jal     ra,80000010 <main>
8000002c:       00050513                mv      a0,a0
80000030:       00100073                ebreak
80000034:       0000006f                j       80000034 <_trm_init+0x1c>
```

> 这个文件被分为了三列, 第一列是编译出的一行二进制指令所在的内存地址; 第二列是这个地址中存储的二进制程序(32位)的十六进制表示(8位); 第三列则是这个二进制指令所对应的汇编程序, 其中第一列表示指令的名称(**操作码**), 第二列表示指令所需的操作数或寄存器名称(**操作数**). 

这样的一个二进制文件就是计算机可以执行的程序啦!

### ISA(指令集)

Risc-V指令集中定义了一系列指令, 任何Risc-V架构的芯片必须能够实现这些指令(还记得吗, 指令集是一个规范手册). 

不同的指令集所提供的指令数量不同, 因此编译器的设计必须也遵顼指令集的约束. Risc-V是一个精简指令集(Risc), 这意味着其中所包含的指令更少, 同时指令的长度是固定的; 而我们更常见到的Intel x86指令集是一个复杂指令集(Cisc), 其中定义的指令更多, 而指令的长度也是会变的. 

> 这里要说明的是, Risc和Cisc是设计上的选择, 两者之间并**没有孰优孰劣之分**. 
> - Risc的每条指令都能在一个时钟周期中执行完毕, 用简单的指令实现更为紧凑的程序执行, 从而提高了运行效率. 同时, 由于Cisc的指令十分复杂, 设计解析指令的电路通常很复杂, 更难以对硬件进行改进更新. 
> - Cisc有十分成熟的商业体系. 同时, Cisc更容易支持并行计算. 
> 在[这里](https://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc/)和[这里](https://blog.sciencenet.cn/blog-414166-763326.html), 我提供两篇文章以供参考. 

下面我也将同一段程序使用x86下的gcc进行编译, 会得到这样的二进制文件: 
```assembly
00100000 <_start>:
  100000:       bd 00 00 00 00          mov    $0x0,%ebp
  100005:       bc 00 90 10 00          mov    $0x109000,%esp
  10000a:       e8 05 00 00 00          call   100014 <_trm_init>
  10000f:       90                      nop

00100010 <main>:
  100010:       31 c0                   xor    %eax,%eax
  100012:       c3                      ret
  100013:       90                      nop

00100014 <_trm_init>:
  100014:       55                      push   %ebp
  100015:       89 e5                   mov    %esp,%ebp
  100017:       83 ec 14                sub    $0x14,%esp
  10001a:       68 40 00 10 00          push   $0x100040
  10001f:       e8 ec ff ff ff          call   100010 <main>
  100024:       cc                      int3
  100025:       83 c4 10                add    $0x10,%esp
  100028:       eb fe                   jmp    100028 <_trm_init+0x14>
```

相信同学们能很明显地看出区别. 

### Hardware(硬件)

在执行程序时: 
- CPU中的PC寄存器会记录目前所执行到的指令的位置(内存地址), 读出其中的内容并存入一个指令寄存器中(**取指**); 
- 接着, CPU会通过一个数字电路将指令中的操作码和操作数分别提取出来(**译码**); 
- 然后, 机器根据指令的内容对于操作数进行一定的操作(**执行**); 
- 最后, PC中存储的值会被修改, 从而开启下一条指令的执行(**更新PC**). 

这四个步骤是所有计算机执行每一条程序的工作, 也是我们编写虚拟机时需要完成的操作. 

## 编写虚拟机

相信大家都能看出, 在程序执行的前三个部分中(程序, 编译器, 指令集), 我们都有现成的工具可以使用, 因此在PA2.1中, 我们的任务就是利用代码完成硬件的工作, 也就是**用软件模拟**出一个Risc-V架构的芯片.

内存在计算机中是一个连续的存储空间, 因此我们使用数组模拟内存; 寄存器是一个有明确结构的存储设备, 因此我们用一个结构体模拟寄存器. 
- **取指**: 取值是十分简单的, 只需要从数组中读取PC对应的空间即可. 
- **译码**: 译码也不困难, 我们依然使用正则表达式进行模式匹配. 
- **执行**: 我们需要为每条指令编写对应的代码实现其功能, 对于Risc-V而言, 由于其中的指令功能都较为单一, 因此也比较简单直接. (虽然讲义要求我们RTFM, 但是我个人觉得STFW在这里是更合理的工具)
- **更新PC**: 一般情况下, 程序只需要顺序执行, 这也就意味着只需要每次将PC移到下一条指令的位置即可, 然而, 对于一些设计跳转的指令来说, 就需要对PC进行特殊处理. 

就这样, 我们的虚拟机就可以运行`C`代码啦~ 

--- 

PA2.1 完成. 